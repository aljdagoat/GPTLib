-- RbxDrawLib.lua
-- Extremely versatile, highly-optimized drawing library for Roblox (client-side)
-- ModuleScript (drop into StarterPlayerScripts or execute in exploit environment)
-- Features:
--  * Object pooling for minimal GC
--  * Batched updates applied on RenderStepped/Heartbeat
--  * Automatic culling (world->screen) and simple LOD
--  * Dirty-checking: only changed properties are applied
--  * Unified API for Drawing (exploit) or GUI fallback (vanilla client)
--  * Groups/layers, tweens, and utility primitives (Line, Circle, Text, Image, Quad)
--  * Lightweight interpolation utilities and fast math helpers

local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

local isDrawingAvailable = (typeof(Drawing) == "table") or (type(Drawing) == "function")

-- Runtime config (tweak if necessary)
local config = {
    updateSignal = RunService.RenderStepped, -- prefer RenderStepped for UI (use Heartbeat for non-UI)
    maxObjectsPerFrame = 8192,               -- safety cap
    cullPadding = 50,                        -- pixels beyond screen to keep objects visible
    lodDistance = 2000,                      -- distance at which certain details are reduced
    defaultFilter = "Always"                -- unused but reserved for future filters
}

-- Fast helpers
local math_abs = math.abs
local math_min = math.min
local math_max = math.max
local math_floor = math.floor
local Vector2_new = Vector2.new
local Vector3_new = Vector3.new

local function devlog(...) end -- replace with warn(...) to debug

-- Object pools to avoid GC churn
local pools = {
    Line = {},
    Circle = {},
    Text = {},
    Image = {},
    Quad = {},
}

-- Active object registry
local activeObjects = setmetatable({}, {__mode = "k"}) -- weak-keys
local pendingApply = {}       -- objects that have property changes to flush
local layers = {}             -- layerName -> {objects...}

-- Simple utility: shallow-copy
local function shallow_copy(t)
    local out = {}
    for k,v in pairs(t) do out[k]=v end
    return out
end

-- Fast property compare
local function same(a,b)
    if a == b then return true end
    if type(a) == "number" and type(b) == "number" then
        return math_abs(a-b) <= 1e-6
    end
    return false
end

-- Basic Tween (frame-based linear interpolation)
local Tween = {}
Tween.__index = Tween
function Tween.new(target, key, from, to, duration, easing)
    return setmetatable({target=target,key=key,from=from,to=to,duration=duration,elapsed=0,easing=easing or function(t) return t end}, Tween)
end
function Tween:update(dt)
    self.elapsed = self.elapsed + dt
    local t = self.elapsed / self.duration
    if t >= 1 then
        local val = self.to
        self.target:Set(self.key, val)
        return true
    end
    t = self.easing(math_min(1, t))
    -- support number and Vector2/3
    local from, to = self.from, self.to
    if typeof(from) == "Vector2" or typeof(from) == "Vector3" then
        local interp = from + (to - from) * t
        self.target:Set(self.key, interp)
    elseif type(from) == "number" then
        self.target:Set(self.key, from + (to - from) * t)
    else
        -- fallback: immediate set last
        self.target:Set(self.key, t < 0.5 and from or to)
    end
    return false
end

-- Low-level creator (Drawing API or GUI fallback)
local function create_raw(typeName)
    if isDrawingAvailable then
        local ok, obj = pcall(function() return Drawing.new(typeName) end)
        if ok and obj then return obj end
        -- fallthrough to GUI fallback if exploit environemnt blocks
    end
    -- GUI fallback: create ScreenGui + Elements
    -- Allowed types here: Line, Text, Circle (draw as ImageLabel quad), Image, Quad
    -- We'll create a Frame/TextLabel/ImageLabel combo, but keep it lightweight.
    local gui = Instance.new("Frame")
    gui.Size = UDim2.new(0,1,0,1)
    gui.BackgroundTransparency = 1
    gui.ClipsDescendants = true
    return gui
end

-- Object wrapper metatable
local ObjMT = {}
ObjMT.__index = ObjMT

function ObjMT:MarkDirty()
    if not self._dirty then
        self._dirty = true
        pendingApply[#pendingApply+1] = self
    end
end

function ObjMT:Set(prop, value)
    local props = self._props
    if same(props[prop], value) then return end
    props[prop] = value
    self:MarkDirty()
end

function ObjMT:Get(prop)
    return self._props[prop]
end

function ObjMT:Hide()
    if self._visible then
        self._visible = false
        self:SetVisible(false)
    end
end
function ObjMT:Show()
    if not self._visible then
        self._visible = true
        self:SetVisible(true)
    end
end

function ObjMT:SetVisible(visible)
    self._props.Visible = visible
    -- direct apply for visibility
    if self._raw and type(self._raw) == "table" then
        pcall(function() self._raw.Visible = visible end)
    else
        pcall(function() self._raw.Visible = visible end)
    end
end

function ObjMT:Destroy()
    if self._raw then
        pcall(function()
            if typeof(self._raw) == "Instance" then
                self._raw:Destroy()
            else
                -- Drawing objects typically have :Remove()
                if type(self._raw.Remove) == "function" then
                    self._raw:Remove()
                end
            end
        end)
    end
    self._raw = nil
    self._props = nil
    self._poolName = nil
    self._destroyed = true
end

-- applies properties to the raw drawing object (only changed ones)
local function apply_to_raw(obj)
    if not obj._raw or obj._destroyed then return end
    local raw = obj._raw
    local props = obj._props
    local typ = obj._type

    -- Drawing API supports specific properties; map ours to raw.
    local ok,err
    if isDrawingAvailable and type(raw) ~= "Instance" then
        -- exploit Drawing APIs: color, thickness, transparency, from, to, position, size, text, center
        ok, err = pcall(function()
            if typ == "Line" then
                raw.From = props.From or Vector2_new(0,0)
                raw.To = props.To or Vector2_new(0,0)
                raw.Thickness = props.Thickness or 1
                raw.Color = props.Color or Color3.new(1,1,1)
                raw.Transparency = props.Transparency or 1
                raw.Visible = props.Visible == nil and true or props.Visible
                raw.ZIndex = props.ZIndex or 1
            elseif typ == "Circle" then
                raw.Position = props.Position or Vector2_new(0,0)
                raw.Radius = props.Radius or 1
                raw.Thickness = props.Thickness or 1
                raw.Color = props.Color or Color3.new(1,1,1)
                raw.Filled = props.Filled or false
                raw.Transparency = props.Transparency or 1
                raw.Visible = props.Visible == nil and true or props.Visible
                raw.ZIndex = props.ZIndex or 1
            elseif typ == "Text" then
                raw.Position = props.Position or Vector2_new(0,0)
                raw.Text = props.Text or ""
                raw.Size = props.Size or 14
                raw.Center = props.Center or false
                raw.Color = props.Color or Color3.new(1,1,1)
                raw.Visible = props.Visible == nil and true or props.Visible
                raw.Outline = props.Outline or false
                raw.Font = props.Font or Enum.Font.SourceSans
            elseif typ == "Image" then
                raw.Position = props.Position or Vector2_new(0,0)
                raw.Size = props.Size or Vector2_new(32,32)
                raw.Data = props.Data -- not always supported
                raw.Transparency = props.Transparency or 1
                raw.Visible = props.Visible == nil and true or props.Visible
            elseif typ == "Quad" then
                raw.PointA = props.PointA or Vector2_new(0,0)
                raw.PointB = props.PointB or Vector2_new(0,0)
                raw.PointC = props.PointC or Vector2_new(0,0)
                raw.PointD = props.PointD or Vector2_new(0,0)
                raw.Thickness = props.Thickness or 1
                raw.Color = props.Color or Color3.new(1,1,1)
                raw.Transparency = props.Transparency or 1
                raw.Visible = props.Visible == nil and true or props.Visible
            end
        end)
        if not ok then
            devlog("Drawing apply error:", err)
        end
    else
        -- GUI fallback: raw is Instance (Frame/TextLabel/ImageLabel)
        pcall(function()
            if typ == "Line" then
                -- represent line as thin Frame rotated + scaled
                local from = props.From or Vector2_new(0,0)
                local to = props.To or Vector2_new(0,0)
                local len = (to - from).Magnitude
                local angle = math.atan2(to.Y - from.Y, to.X - from.X)
                raw.Position = UDim2.new(0, from.X, 0, from.Y)
                raw.Size = UDim2.new(0, len, 0, props.Thickness or 2)
                raw.Rotation = angle * 180/math.pi
                raw.BackgroundTransparency = props.Transparency and (1-props.Transparency) or 0
                raw.BackgroundColor3 = props.Color or Color3.new(1,1,1)
                raw.Visible = props.Visible == nil and true or props.Visible
            elseif typ == "Text" then
                raw.Position = UDim2.new(0, (props.Position or Vector2_new(0,0)).X, 0, (props.Position or Vector2_new(0,0)).Y)
                raw.Size = UDim2.new(0, 200, 0, (props.Size or 14) * 1.5)
                raw.Visible = props.Visible == nil and true or props.Visible
                if raw:IsA("TextLabel") then
                    raw.Text = props.Text or ""
                    raw.TextSize = props.Size or 14
                    raw.TextColor3 = props.Color or Color3.new(1,1,1)
                    raw.TextXAlignment = props.Center and Enum.TextXAlignment.Center or Enum.TextXAlignment.Left
                end
            elseif typ == "Circle" then
                -- approximate by ImageLabel with circle image resource (not bundled). simple square fallback
                raw.Position = UDim2.new(0, (props.Position or Vector2_new(0,0)).X, 0, (props.Position or Vector2_new(0,0)).Y)
                local r = (props.Radius or 4) * 2
                raw.Size = UDim2.new(0, r, 0, r)
                raw.Visible = props.Visible == nil and true or props.Visible
                raw.BackgroundTransparency = props.Filled and 0 or 1
                raw.BorderSizePixel = 0
                raw.BackgroundColor3 = props.Color or Color3.new(1,1,1)
            end
        end)
    end
end

-- Create or reuse object
local function acquire(typeName)
    local pool = pools[typeName]
    local raw = nil
    if pool and #pool > 0 then
        raw = table.remove(pool)
    else
        raw = create_raw(typeName)
    end

    local wrapper = setmetatable({}, ObjMT)
    wrapper._raw = raw
    wrapper._type = typeName
    wrapper._props = {}
    wrapper._dirty = false
    wrapper._visible = true
    wrapper._poolName = typeName
    wrapper._tweens = {}

    activeObjects[wrapper] = true
    return wrapper
end

-- Release object back to pool
local function release(obj)
    if not obj or obj._destroyed then return end
    obj:Destroy()
    local poolName = obj._poolName
    if poolName and pools[poolName] then
        -- try to reuse raw if it's an Instance; else discard
        if obj._raw and typeof(obj._raw) == "Instance" then
            table.insert(pools[poolName], obj._raw)
        end
    end
end

-- Public API
local RbxDraw = {}
RbxDraw.__index = RbxDraw

function RbxDraw.New(typeName, props)
    local o = acquire(typeName)
    if props then
        for k,v in pairs(props) do o:Set(k,v) end
    end
    -- mark immediate apply
    o:MarkDirty()
    return o
end

function RbxDraw.CreateLine(from, to, color, thickness)
    return RbxDraw.New("Line", {From = from or Vector2_new(0,0), To = to or Vector2_new(0,0), Color = color or Color3.new(1,1,1), Thickness = thickness or 1})
end
function RbxDraw.CreateCircle(pos, radius, color, filled)
    return RbxDraw.New("Circle", {Position = pos or Vector2_new(0,0), Radius = radius or 4, Color = color or Color3.new(1,1,1), Filled = filled or false})
end
function RbxDraw.CreateText(pos, text, size, color)
    return RbxDraw.New("Text", {Position = pos or Vector2_new(0,0), Text = text or "", Size = size or 14, Color = color or Color3.new(1,1,1)})
end
function RbxDraw.CreateImage(pos, size, data)
    return RbxDraw.New("Image", {Position = pos or Vector2_new(0,0), Size = size or Vector2_new(32,32), Data = data})
end

-- Layer management
function RbxDraw.CreateLayer(name)
    if not layers[name] then layers[name] = {} end
    return layers[name]
end
function RbxDraw.AddToLayer(layerName, obj)
    local layer = layers[layerName] or RbxDraw.CreateLayer(layerName)
    layer[#layer+1] = obj
end

-- Simple tween helper
function RbxDraw.Tween(obj, key, to, duration, easing)
    local tw = Tween.new(obj, key, obj:Get(key), to, duration or 0.2, easing)
    obj._tweens[#obj._tweens+1] = tw
    return tw
end

-- Internal update: flush pending applies
local runningTweens = {}

local function flushPending()
    -- cap to avoid frame stalls
    local cap = config.maxObjectsPerFrame
    local count = 0
    while #pendingApply > 0 and count < cap do
        local obj = table.remove(pendingApply, 1)
        if obj and not obj._destroyed then
            apply_to_raw(obj)
            obj._dirty = false
        end
        count = count + 1
    end
    if #pendingApply > 0 then
        -- still items - they'll be processed next frame; that's fine
    end
end

local last_time = tick()
local function update(dt)
    -- update tweens
    for obj,_ in pairs(activeObjects) do
        if obj._tweens and #obj._tweens > 0 then
            for i = #obj._tweens, 1, -1 do
                local tw = obj._tweens[i]
                local done = tw:update(dt)
                if done then table.remove(obj._tweens,i) end
            end
        end
    end
    -- grouped culling and LOD (basic example)
    if Camera then
        local viewportSize = Camera.ViewportSize
        for obj,_ in pairs(activeObjects) do
            local props = obj._props
            -- quick cull for things with world points
            if props.WorldPosition then
                local ok, sx, sy, onScreen = pcall(function()
                    local p = Camera:WorldToViewportPoint(props.WorldPosition)
                    return p.Z > 0, p.X, p.Y, p.Z > 0
                end)
                if ok then
                    local px, py = sx, sy
                    local pad = config.cullPadding
                    local visible = (px >= -pad and px <= viewportSize.X + pad and py >= -pad and py <= viewportSize.Y + pad)
                    obj:SetVisible(visible)
                    if visible then
                        obj:Set("Position", Vector2_new(px,py))
                    end
                end
            end
        end
    end
    flushPending()
end

-- connect update
config.updateSignal:Connect(function(step)
    update(step)
end)

-- Utility helpers
function RbxDraw.WorldToScreen(worldPos)
    if Camera then
        local p = Camera:WorldToViewportPoint(worldPos)
        return Vector2_new(p.X, p.Y), p.Z > 0
    end
    return Vector2_new(0,0), false
end

function RbxDraw.ClearLayer(name)
    local layer = layers[name]
    if not layer then return end
    for _,obj in ipairs(layer) do
        if obj and not obj._destroyed then obj:Destroy() end
    end
    layers[name] = {}
end

function RbxDraw.Destroy(obj)
    if not obj then return end
    if type(obj) == "table" and obj._poolName then
        obj:Destroy()
    end
end

-- Return module
return RbxDraw
